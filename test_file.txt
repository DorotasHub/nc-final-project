import json
from unittest.mock import patch, MagicMock
import pandas as pd
import pytest
from data_loading import create_engine_conn, get_object_path, load_data, lambda_handler, PROCESSED_BUCKET
import time
from botocore.exceptions import ClientError
import logging


logger = logging.getLogger()
logger.setLevel(logging.DEBUG)

@patch("data_loading.boto3.client")  
def test_create_engine_conn(mock_boto_client):
    mock_secrets_manager = mock_boto_client.return_value
    mock_secrets_manager.get_secret_value.return_value = {
        "SecretString": json.dumps({
            "username": "test_user",
            "password": "test_password",
            "dbname": "test_db",
            "port": 5432,
            "host": "test_host"
        })
    }
    conn_string = create_engine_conn("test-secret", mock_secrets_manager)

    expected = "postgresql://test_user:test_password@test_host:5432/test_db"
    assert conn_string == expected

def test_create_engine_conn_error():
    mock_secrets_manager = MagicMock()
    mock_secrets_manager.get_secret_value.side_effect = ClientError(
        {"Error": {"Code": "NoSuchEntity", "Message": "Secret not found"}}, "GetSecretValue"
    )
    conn_string = create_engine_conn("data-warehouse-creds", mock_secrets_manager)
    assert conn_string is None

def test_get_object_path():
    mock_event = {
        "Records": [
            {
                "s3": {
                    "bucket": {
                        "name": "my-bucket"
                    },
                    "object": {
                        "key": "1/2/3.parquet"
                    }
                }
            }
        ]
    }
    bucket_name, object_key = get_object_path(mock_event["Records"])

    assert bucket_name == "my-bucket"
    assert object_key == "1/2/3.parquet"

@patch("data_loading.wr.s3.read_parquet")  
@patch("data_loading.pd.DataFrame.to_sql")  
def test_load_data_error_handling(mock_to_sql, mock_read_parquet):
    mock_conn = MagicMock()
    mock_read_parquet.side_effect = ClientError(
        {"Error": {"Code": "NoSuchKey", "Message": "The specified key does not exist."}}, "GetObject"
    )
    load_data("non_existent_file", mock_conn) 
    mock_read_parquet.assert_called_once_with(f"s3://{PROCESSED_BUCKET}/non_existent_file/*", dataset=True)

    mock_to_sql.assert_not_called()



@patch("data_loading.wr.s3.read_parquet")
@patch("data_loading.pd.DataFrame.to_sql")
def test_load_data_address(mock_to_sql, mock_read_parquet):
    mock_conn = MagicMock()

    # Simulate S3 read success with mock data for the address
    mock_read_parquet.return_value = pd.DataFrame({
        "location_id": [1, 2, 3],
        "address_line_1": ["123 Main St", "456 Oak St", "789 Pine St"],
        "address_line_2": ["Apt 1", "Apt 2", "Apt 3"],
        "district": ["Downtown", "Uptown", "Midtown"],
        "city": ["CityA", "CityB", "CityC"],
        "postal_code": ["12345", "23456", "34567"],
        "country": ["CountryA", "CountryB", "CountryC"],
        "phone": ["111-222-3333", "222-333-4444", "333-444-5555"]
    })

    logger.info("=== Running load_data for address ===")
    load_data("address", mock_conn)


    mock_read_parquet.assert_called_once_with(f"s3://{PROCESSED_BUCKET}/address/*", dataset=True)


    args, kwargs = mock_to_sql.call_args  # Get the arguments passed to the to_sql function
    logger.debug(f"Arguments passed to to_sql: {args}, {kwargs}")

    df_inserted = args[0] 
    logger.debug(f"Captured DataFrame passed to to_sql:\n{df_inserted}")


    expected_df = pd.DataFrame({
        "location_id": [1, 2, 3],
        "address_line_1": ["123 Main St", "456 Oak St", "789 Pine St"],
        "address_line_2": ["Apt 1", "Apt 2", "Apt 3"],
        "district": ["Downtown", "Uptown", "Midtown"],
        "city": ["CityA", "CityB", "CityC"],
        "postal_code": ["12345", "23456", "34567"],
        "country": ["CountryA", "CountryB", "CountryC"],
        "phone": ["111-222-3333", "222-333-4444", "333-444-5555"]
    })
    logger.debug(f"Expected DataFrame:\n{expected_df}")


    assert isinstance(df_inserted, pd.DataFrame), f"Expected DataFrame, but got {type(df_inserted)}"
    try:
        pd.testing.assert_frame_equal(df_inserted, expected_df)
    except AssertionError as e:
        logger.error(f"Assertion Error: {str(e)}")
        raise e
